// -- Base constants
/// @dev Non zero slot allows for the omission of zero checks in certain view methods (e.g. `balanceOf`)
/// @notice Determined via keccak256("YAM_WETH.totalSupply") - 1
#define constant TOTAL_SUPPLY_SLOT = 0xd56ede8fae84e89fcc30c580c1e75530f248a337be6f2dd2c582e96a7859b532
#define constant CHAIN_ID = 0x01 // Main deployment will be on Ethereum
#define constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

// -- ABI Constants
#define event Transfer(address indexed, address indexed, uint256)
#define event Approval(address indexed, address indexed, uint256)

#define error InsufficientBalance()

// -- ERC712 Constants
#define constant ERC712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f
#define constant NAME_HASH = 0x71ad9062969277156f043087ef6affb03325435a01d7a4ba510de93ca3859a76
#define constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6


// -- Utility Functions
#define macro BRANCHLESS_ASSERT_ZERO() = takes(1) returns(0) {
    // takes:    [cond]
    returndatasize returndatasize returndatacopy
}

#define macro REQUIRE_ADDRESS() = takes(1) returns(0) {
    // takes:        [addr]
    dup1 0xffffffffffffffffffffffffffffffffffffffff and  // [uint160(addr), addr]
    dup2 iszero                                          // [addr == 0, uint160(addr), addr]
    swap2 sub                                            // [uint160(addr) - addr, addr == 0]
    or BRANCHLESS_ASSERT_ZERO()
}

#define macro REVERT(zero) = takes(1) returns(0) {
    <zero> mstore
    0x04 0x1c return
}

#define macro RETURN_SUCCESS(zero) = takes(0) returns(0) {
    0x01 <zero> mstore
    0x20 <zero> return
}

#define macro BUBBLE_REVERT(zero) = takes(1) returns(0) {
    // takes:             [success]
    no_bubble jumpi
    returndatasize <zero> <zero> returndatacopy
    returndatasize <zero> revert
    no_bubble:
}


// -- External Functions
// ---- Metadata / Global Methods
#define macro _NAME_EXTERNAL(zero) = takes(0) returns(0) {
    // "Yet Another Maximized Wrapped Ether Contract" (len: 44)
    0x7468657220436f6e7472616374 0x4c mstore
    0x2c59657420416e6f74686572204d6178696d697a656420577261707065642045 0x3f mstore
    0x20 <zero> mstore
    msize <zero> return
}

#define macro _SYMBOL_EXTERNAL(zero) = takes(0) returns(0) {
    // "WETH"
    0x0457455448 0x24 mstore
    0x20 <zero> mstore
    msize <zero> return
}

#define macro _DECIMALS_EXTERNAL(zero) = takes(0) returns(0) {
    0x12 <zero> mstore
    0x20 <zeso> return
}

#define macro _TOTAL_SUPPLY_EXTERNAL(zero) = takes(0) returns(0) {
    [TOTAL_SUPPLY_SLOT] sload <zero> mstore
    0x20 <zero> return
}

// ---- Transfer related methods
#define macro _BALANCE_OF_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload       // [account]
    dup1 REQUIRE_ADDRESS()  // [account]
    sload <zero> mstore     // []
    0x20 <zero> return
}

#define macro TRANSFER(zero) = takes(5) returns(0) {
    // takes:             [from, amount, amount, from, to]

    // -- Update `from` Balance
    sload dup1         // [from.bal, from.bal, amount, amount, from, to]
    dup3               // [amount, from.bal, from.bal, amount, amount, from, to]
    gt insufficient_bal_error jumpi
    //                    [from.bal, amount, amount, from, to]
    sub                // [from.bal', amount, from, to]
    dup3 sstore        // [amount, from, to]

    // -- Update `to` Balance
    dup3 sload         // [to.bal, amount, from, to]
    dup2 add           // [to.bal', amount, from, to]
    dup4 sstore        // [amount, from, to]

    // -- Emit `Transfer`
    <zero> mstore      // [from, to]
    __EVENT_HASH(Transfer)
    //                    [Transfer.sig, from, to]
    0x20 <zero> log3   // []
}

#define macro _TRANSFER_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Verify Params
    0x04 calldataload // [to]
    dup1 REQUIRE_ADDRESS()
    caller            // [msg.sender, to]
    0x24 calldataload // [amount, msg.sender, to]

    // -- Transfer
    dup1 caller       // [msg.sender, amount, amount, msg.sender, to]
    TRANSFER(<zero>)

    RETURN_SUCCESS(<zero>)
}

#define macro _APPROVE_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Verify Params
    0x04 calldataload      // [spender]
    0x24 calldataload      // [amount, spender]
    dup2 REQUIRE_ADDRESS() // [amount, spender]

    // -- Store approval
    caller <zero> mstore   // [amount, spender]
    dup2    0x20  mstore   // [amount, spender]
    dup1                   // [amount, amount, spender]
    0x40 <zero> sha3       // [allowance.slot, amount, amount, spender]
    sstore                 // [amount, spender]

    // -- Emit Event
    <zero> mstore          // [spender]
    caller                 // [owner, spender]
    __EVENT_HASH(Approval) // [Approval.sig, owner, spender]
    0x20 <zero> log3       // []

    RETURN_SUCCESS(<zero>)
}

#define macro _ALLOWANCE_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload // [owner]
    0x24 calldataload // [spender, owner]
    dup2 dup2 or REQUIRE_ADDRESS()
     0x20  mstore     // [owner]
    <zero> mstore     // []
    0x40 <zero> sha3  // [allowance.slot]
    sload             // [allowance]
    <zero> mstore     // []
    0x20 <zero> return
}

#define macro _TRANSFER_FROM_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Do Param Verification
    0x24 calldataload  // [to]
    0x04 calldataload  // [from, to]
    0x44 calldataload  // [amount, from, to]
    dup3 dup3 or REQUIRE_ADDRESS()
    //                    [amount, from, to]

    // -- Verify Allowance
    dup2 <zero> mstore // [amount, from, to]
    caller 0x20 mstore // [amount, from, to]
    0x40 <zero> sha3   // [allowance.slot, amount, from, to]
    dup1 sload         // [allowance, allowance.slot, amount, from, to]
    dup1 [MAX_UINT] eq inf_allowance_transfer_from jumpi
    //                    [allowance, allowance.slot, amount, from, to]
    dup1 dup4          // [amount, allowance, allowance, allowance.slot, amount, from, to]
    gt insufficient_allowance_error jumpi
    //                    [allowance, allowance.slot, amount, from, to]
    dup3 swap1 sub     // [allowance', allowance.slot, amount, from, to]
    swap1 sstore       // [amount, from, to]

    // -- Finish Transfer
    dup1 dup3          // [from, amount, amount, from, to]
    TRANSFER(<zero>)
    RETURN_SUCCESS(<zero>)

    inf_allowance_transfer_from:
    //                    [allowance, allowance.slot, amount, from, to]
    pop pop            // [amount, from, to]
    dup1 dup3          // [from, amount, amount, from, to]
    TRANSFER(<zero>)
    RETURN_SUCCESS(<zero>)
}

#define macro _DEPOSIT_EXTERNAL(zero) = takes(0) returns(0) {
    [TOTAL_SUPPLY_SLOT] // [total_supply.slot]
    dup1 sload          // [total_supply, total_supply.slot]
    selfbalance sub     // [amount, total_supply.slot]
    dup1                // [amount, amount, total_supply.slot]
    caller sload        // [msg.sender.bal, amount, amount, total_supply.slot]
    add                 // [msg.sender.bal', amount, total_supply.slot]
    caller sstore       // [amount, total_supply.slot]

    // -- Emit Transfer
    <zero> mstore       // [total_supply.slot]
    caller <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, msg.sender, total_supply.slot]
    0x20 <zero> log3    // [total_supply.slot]

    // -- Update Total Supply
    selfbalance swap1   // [total_supply.slot, this.balance]
    sstore              // []

    RETURN_SUCCESS(<zero>)
}

#define macro _DEPOSIT_TO_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload   // [recipient]
    dup1 REQUIRE_ADDRESS()

    [TOTAL_SUPPLY_SLOT] // [total_supply.slot, recipient]
    dup1 sload          // [total_supply, total_supply.slot, recipient]
    selfbalance sub     // [amount, total_supply.slot, recipient]
    dup1                // [amount, amount, total_supply.slot, recipient]
    dup4 sload          // [recipient.bal, amount, amount, total_supply.slot, recipient]
    add                 // [recipient.bal', amount, total_supply.slot, recipient]
    dup4 sstore         // [amount, total_supply.slot, recipient]

    // -- Emit Transfer
    <zero> mstore       // [total_supply.slot, recipient]
    swap1 <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, recipient, total_supply.slot]
    0x20 <zero> log3    // [total_supply.slot]

    // -- Update Total Supply
    selfbalance swap1   // [total_supply.slot, this.balance]
    sstore              // []

    RETURN_SUCCESS(<zero>)
}

#define macro _WITHDRAW_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload     // [amount]

    // -- Update Balance
    dup1                  // [amount, amount]
    caller sload          // [msg.sender.bal, amount, amount]
    dup1 dup3             // [amount, msg.sender.bal, msg.sender.bal, amount, amount]
    gt insufficient_bal_error jumpi
    //                       [msg.sender.bal, amount, amount]
    sub                   // [msg.sender.bal', amount]
    caller sstore         // [amount]

    // -- Update Total Supply
    [TOTAL_SUPPLY_SLOT]   // [total_supply.slot, amount]
    dup2 dup2             // [total_supply.slot, amount, total_supply.slot, amount]
    sload sub             // [total_supply', total_supply.slot, amount]
    swap1 sstore          // [amount]

    // -- Emit Transfer
    dup1 <zero> mstore    // [amount]
    <zero> caller __EVENT_HASH(Transfer)
    //                       [Transfer.sig, recipient, msg.sender, amount]
    0x20 <zero> log3      // [amount]

    // -- Transfer out ETH
    <zero> <zero> <zero> <zero>
    //                       [0, 0, 0, 0, amount]
    swap4 caller gas      // [gas, msg.sender, amount, 0, 0, 0, 0]
    call                  // [success]
    BUBBLE_REVERT(<zero>) // []

    RETURN_SUCCESS(<zero>)
}

#define jumptable__packed FN_TABLE {
    depositAmountTo nonces withdrawFrom deposit depositAmount symbol no_selector_match withdraw balanceOf no_selector_match withdrawTo decimals name no_selector_match no_selector_match no_selector_match no_selector_match approve no_selector_match DOMAIN_SEPARATOR withdrawFromTo transferFrom no_selector_match no_selector_match transfer depositTo permit no_selector_match allowance totalSupply no_selector_match multicall
}

#define macro _MAIN(zero) = takes(0) returns(0) {
    <zero> calldataload // [cd[0]]
    // -- store selector
    dup1 msize mstore   // [cd[0]]
    // -- store nonce (also clears non-selector calldata)
    0x574 0x4 mstore
    // jump label size
    0x2                 // [2, cd[0]]
    // -- get function index
    msize <zero> sha3 0x3e and
    //                     [function_index << 1, 2, cd[0]]
    // -- load jump label
    __tablestart(FN_TABLE) add
    0x5e codecopy       // [cd[0]]
    0xe0 shr            // [selector]
    0x40 mload          // [jump_loc, selector]
    // -- use jump label
    jump

    name:
        dup1 0x06fdde03 sub no_selector_match jumpi
        _NAME_EXTERNAL(<zero>)
    symbol:
        dup1 0x95d89b41 sub no_selector_match jumpi
        _SYMBOL_EXTERNAL(<zero>)
    decimals:
        dup1 0x313ce567 sub no_selector_match jumpi
        _DECIMALS_EXTERNAL(<zero>)
    totalSupply:
        dup1 0x18160ddd sub no_selector_match jumpi
        _TOTAL_SUPPLY_EXTERNAL(<zero>)
    transferFrom:
        dup1 0x23b872dd sub no_selector_match jumpi
    transfer:
        dup1 0xa9059cbb sub no_selector_match jumpi
        _TRANSFER_EXTERNAL(<zero>)
    balanceOf:
        dup1 0x70a08231 sub no_selector_match jumpi
        _BALANCE_OF_EXTERNAL(<zero>)
    approve:
        dup1 0x095ea7b3 sub no_selector_match jumpi
        _APPROVE_EXTERNAL(<zero>)
    allowance:
        dup1 0xdd62ed3e sub no_selector_match jumpi
        _ALLOWANCE_EXTERNAL(<zero>)
    deposit:
        dup1 0xd0e30db0 sub no_selector_match jumpi
        _DEPOSIT_EXTERNAL(<zero>)
    depositTo:
        dup1 0xb760faf9 sub no_selector_match jumpi
        _DEPOSIT_TO_EXTERNAL(<zero>)
    depositAmountTo:
        dup1 0xb2069e40 sub no_selector_match jumpi
    depositAmount:
        dup1 0x87f8ab26 sub no_selector_match jumpi
    withdraw:
        dup1 0x2e1a7d4d sub no_selector_match jumpi
        _WITHDRAW_EXTERNAL(<zero>)
    withdrawTo:
        dup1 0x205c2878 sub no_selector_match jumpi
    withdrawFrom:
        dup1 0x9470b0bd sub no_selector_match jumpi
    withdrawFromTo:
        dup1 0xc8993196 sub no_selector_match jumpi
    DOMAIN_SEPARATOR:
        dup1 0x3644e515 sub no_selector_match jumpi
    nonces:
        dup1 0x7ecebe00 sub no_selector_match jumpi
    permit:
        dup1 0xd505accf sub no_selector_match jumpi
    multicall:
        dup1 0xac9650d8 sub no_selector_match jumpi
    no_selector_match:
        calldatasize unmatching_nonempty jumpi
        _DEPOSIT_EXTERNAL(<zero>)
        unmatching_nonempty:
            <zero> <zero> revert

    insufficient_bal_error:
        __FUNC_SIG(InsufficientBalance) REVERT(<zero>)
    insufficient_allowance_error:
        __FUNC_SIG(InsufficientBalance) REVERT(<zero>)


}

#define macro MAIN() = takes(0) returns(0) {
  _MAIN(returndatasize)
}
