// -- Base constants
/// @dev Non zero slot allows for the omission of zero checks in certain view methods (e.g. `balanceOf`)
/// @notice Determined via keccak256("YAM_WETH.totalSupply") - 1
#define constant TOTAL_SUPPLY_SLOT = 0xd56ede8fae84e89fcc30c580c1e75530f248a337be6f2dd2c582e96a7859b532
#define constant BALANCE_MASK = 0xffffffffffffffffffffffffffffffff
#define constant NONCE_SHIFT = 0x80
#define constant MAINNET_CHAIN_ID = 0x01 // Main deployment will be on Ethereum
#define constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
#define constant DECIMALS = 0x12 // 18

// -- ABI Constants
// ---- Functions
// ---- Functions -- Metadata
#define function name() view returns (string)
#define function symbol() view returns (string)
#define function decimals() view returns (uint8)
// ---- Functions -- Global
#define function totalSupply() view returns (uint256)
// ---- Functions -- Transfer
#define function transferFrom(address,address,uint256) payable returns (bool)
#define function transfer(address, uint256) payable returns (bool)
#define function balanceOf(address) view returns (uint256)
// ---- Functions -- Allowance
#define function approve(address,uint256) payable returns (bool)
#define function allowance(address, address) view returns (uint256)
// ---- Functions -- ERC2612 Permits
#define function DOMAIN_SEPARATOR() view returns (bytes32)
#define function nonces(address) view returns (uint256)
#define function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) payable returns ()
// ---- Functions -- Utility
#define function multicall(bytes[]) payable returns (bytes[])
// ---- Functions -- Wrap
#define function deposit() payable returns ()
#define function depositTo(address) payable returns ()
#define function depositAmountTo(address, uint256) payable returns ()
#define function depositAmount(uint256) payable returns ()
// ---- Functions -- Unwrap
#define function withdraw(uint256) payable returns ()
#define function withdrawTo(address, uint256) payable returns ()
#define function withdrawFrom(address, uint256) payable returns ()
#define function withdrawFromTo(address, address, uint256) payable returns ()

// ---- Events
#define event Transfer(address indexed, address indexed, uint256)
#define event Approval(address indexed, address indexed, uint256)

// ---- Errors
#define error InsufficientBalance()
#define error InsufficientAllowance()
#define error InsufficientFreeBalance()

// -- ERC712 Constants
// keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
#define constant ERC712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f
#define constant NAME_HASH = 0x71ad9062969277156f043087ef6affb03325435a01d7a4ba510de93ca3859a76
#define constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6
#define constant CACHED_DOMAIN_SEPARATOR = 0xd00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d00d001


// -- Utility Functions
#define macro BRANCHLESS_ASSERT_ZERO() = takes(1) returns(0) {
    // takes:    [cond]
    returndatasize returndatasize returndatacopy
}

#define macro REQUIRE_ADDRESS() = takes(1) returns(0) {
    // takes:        [addr]
    dup1 0xffffffffffffffffffffffffffffffffffffffff and  // [uint160(addr), addr]
    dup2 iszero                                          // [addr == 0, uint160(addr), addr]
    swap2 sub                                            // [uint160(addr) - addr, addr == 0]
    or BRANCHLESS_ASSERT_ZERO()
}

#define macro LOAD_ADDRESS() = takes(1) returns(1) {
    // takes:         [calldata_pos]
    calldataload   // [addr]
    dup1 REQUIRE_ADDRESS()
    // returns:    // [addr] 
}

#define macro REVERT(zero) = takes(1) returns(0) {
    <zero> mstore
    0x04 0x1c return
}

#define macro RETURN_WORD(zero) = takes(1) returns(0) {
    // takes:             [x]
    <zero> mstore      // []
    0x20 <zero> return // []
}

#define macro RETURN_TRUE(zero) = takes(0) returns(0) {
    0x1 RETURN_WORD(<zero>)
}

#define macro BUBBLE_REVERT(zero) = takes(1) returns(0) {
    // takes:             [success]
    no_bubble jumpi
        returndatasize <zero> <zero> returndatacopy
        returndatasize <zero> revert
    no_bubble:
}

#define macro NO_VALUE() = takes(0) returns(0) {
    callvalue empty_revert jumpi
}

#define macro SEND_ETH_TO_CALLER(zero, zero2) = takes(1) returns(0) {
    // takes:                      [amount]

    <zero> <zero> <zero> <zero> // [0, 0, 0, 0, amount]
    swap4 caller gas            // [gas, msg.sender, amount, 0, 0, 0, 0]
    call                        // [success]
    BUBBLE_REVERT(<zero2>)       // []

    // returns:                    []
}

#define macro SEND_ETH(zero, zero2) = takes(2) returns(0) {
    // takes:        [amount, recipient]

    <zero> <zero> // [0, 0, amount, recipient]
    <zero>        // [0, 0, 0, amount, recipient]
    swap3         // [amount, 0, 0, 0, recipient]
    <zero>        // [0, amount, 0, 0, 0, recipient]
    swap5         // [recipient, amount, 0, 0, 0, 0]
    gas call      // [success]
    BUBBLE_REVERT(<zero2>)
}

// -- External Functions
// ---- Metadata / Global Methods
#define macro _NAME_EXTERNAL(zero) = takes(0) returns(0) {
    // "Yet Another Maximized Wrapped Ether Contract" (len: 44)
    0x7468657220436f6e7472616374 0x4c mstore
    0x2c59657420416e6f74686572204d6178696d697a656420577261707065642045 0x3f mstore
    0x20 <zero> mstore
    msize <zero> return
}

#define macro _SYMBOL_EXTERNAL(zero) = takes(0) returns(0) {
    // "WETH"
    0x0457455448 0x24 mstore
    0x20 <zero> mstore
    msize <zero> return
}

#define macro _DECIMALS_EXTERNAL(zero) = takes(0) returns(0) {
    [DECIMALS] RETURN_WORD(<zero>)
}

#define macro _TOTAL_SUPPLY_EXTERNAL(zero) = takes(0) returns(0) {
    [TOTAL_SUPPLY_SLOT] sload RETURN_WORD(<zero>)
}

#define macro LOAD_BALANCE() = takes(1) returns(1) {
    sload [BALANCE_MASK] and
}

// ---- Transfer related methods
#define macro _BALANCE_OF_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 LOAD_ADDRESS()     // [account]
    LOAD_BALANCE()          // [account.bal]
    RETURN_WORD(<zero>)
}

#define macro TRANSFER(zero) = takes(5) returns(0) {
    // takes:             [from, amount, amount, from, to]

    // -- Update `from` Balance
    sload dup1         // [from.data, from.data, amount, amount, from, to]
    [BALANCE_MASK] and // [from.bal, from.data, amount, amount, from, to]
    dup3               // [amount, from.bal, from.data, amount, amount, from, to]
    gt insufficient_bal_error jumpi
    //                    [from.data, amount, amount, from, to]
    sub                // [from.data', amount, from, to]
    dup3 sstore        // [amount, from, to]

    // -- Update `to` Balance
    dup3 sload         // [to.data, amount, from, to]
    dup2 add           // [to.data', amount, from, to]
    dup4 sstore        // [amount, from, to]

    // -- Emit `Transfer`
    <zero> mstore      // [from, to]
    __EVENT_HASH(Transfer)
    //                    [Transfer.sig, from, to]
    0x20 <zero> log3   // []
}

#define macro _TRANSFER_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Verify Params
    0x04 LOAD_ADDRESS() // [to]
    caller              // [msg.sender, to]
    0x24 calldataload   // [amount, msg.sender, to]

    // -- Transfer
    dup1 caller         // [msg.sender, amount, amount, msg.sender, to]
    TRANSFER(<zero>)

    RETURN_TRUE(<zero>)
}

#define macro _APPROVE_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Verify Params
    0x04 LOAD_ADDRESS()    // [spender]
    0x24 calldataload      // [amount, spender]

    // -- Store approval
    caller <zero> mstore   // [amount, spender]
    dup2    0x20  mstore   // [amount, spender]
    dup1                   // [amount, amount, spender]
    0x40 <zero> sha3       // [allowance.slot, amount, amount, spender]
    sstore                 // [amount, spender]

    // -- Emit Event
    <zero> mstore          // [spender]
    caller                 // [owner, spender]
    __EVENT_HASH(Approval) // [Approval.sig, owner, spender]
    0x20 <zero> log3       // []

    RETURN_TRUE(<zero>)
}

#define macro _ALLOWANCE_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload // [owner]
    0x24 calldataload // [spender, owner]
    dup2 dup2 or REQUIRE_ADDRESS()
     0x20  mstore     // [owner]
    <zero> mstore     // []
    0x40 <zero> sha3  // [allowance.slot]
    sload             // [allowance]
    <zero> mstore     // []
    0x20 <zero> return
}


// Actually "returns" 4 if jumping to `use_allowance_2pop`
/// @dev Checks and updates `from`'s allowance to caller
#define macro USE_ALLOWANCE(zero, use_allowance_2pop) = takes(2) returns(2) {
    // takes:             [amount, from]
    dup2 <zero> mstore // [amount, from]
    caller 0x20 mstore // [amount, from]
    0x40 <zero> sha3   // [allowance.slot, amount, from]
    dup1 sload         // [allowance, allowance.slot, amount, from]
    dup1 [MAX_UINT] eq <use_allowance_2pop> jumpi
    //                    [allowance, allowance.slot, amount, from]
    dup1 dup4          // [amount, allowance, allowance, allowance.slot, amount, from]
    gt insufficient_allowance_error jumpi
    //                    [allowance, allowance.slot, amount, from]
    dup3 swap1 sub     // [allowance', allowance.slot, amount, from]
    swap1 sstore       // [amount, from]
}

#define macro TRANSFER_FROM_END(zero) = takes(3) returns(0) {
    // takes:             [amount, from, to]
    dup1 dup3          // [from, amount, amount, from, to]
    TRANSFER(<zero>)   // []
    RETURN_TRUE(<zero>)
}

#define macro _TRANSFER_FROM_EXTERNAL(zero) = takes(0) returns(0) {
    // -- Load & Do Param Verification
    0x24 calldataload  // [to]
    0x04 calldataload  // [from, to]
    0x44 calldataload  // [amount, from, to]
    dup3 dup3 or REQUIRE_ADDRESS()
    //                    [amount, from, to]

    // -- Verify Allowance
    USE_ALLOWANCE(<zero>, transfer_from_allowed_2pop)
        //                  [amount, from, to]
        TRANSFER_FROM_END(<zero>)
    transfer_from_allowed_2pop:
        //                [allowance, allowance.slot, amount, from, to]
        pop pop        // [amount, from, to]
        TRANSFER_FROM_END(<zero>)
}

#define macro _DEPOSIT_EXTERNAL(zero) = takes(0) returns(0) {
    [TOTAL_SUPPLY_SLOT] // [total_supply.slot]
    dup1 sload          // [total_supply, total_supply.slot]
    selfbalance sub     // [amount, total_supply.slot]
    dup1                // [amount, amount, total_supply.slot]
    caller sload        // [msg.sender.bal, amount, amount, total_supply.slot]
    add                 // [msg.sender.bal', amount, total_supply.slot]
    caller sstore       // [amount, total_supply.slot]

    // -- Emit Transfer
    <zero> mstore       // [total_supply.slot]
    caller <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, msg.sender, total_supply.slot]
    0x20 <zero> log3    // [total_supply.slot]

    // -- Update Total Supply
    selfbalance swap1   // [total_supply.slot, this.balance]
    sstore              // []

    stop
}

#define macro _DEPOSIT_TO_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 LOAD_ADDRESS() // [recipient]

    [TOTAL_SUPPLY_SLOT] // [total_supply.slot, recipient]
    dup1 sload          // [total_supply, total_supply.slot, recipient]
    selfbalance sub     // [amount, total_supply.slot, recipient]
    dup1                // [amount, amount, total_supply.slot, recipient]
    dup4 sload          // [recipient.bal, amount, amount, total_supply.slot, recipient]
    add                 // [recipient.bal', amount, total_supply.slot, recipient]
    dup4 sstore         // [amount, total_supply.slot, recipient]

    // -- Emit Transfer
    <zero> mstore       // [total_supply.slot, recipient]
    swap1 <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, recipient, total_supply.slot]
    0x20 <zero> log3    // [total_supply.slot]

    // -- Update Total Supply
    selfbalance swap1   // [total_supply.slot, this.balance]
    sstore              // []

    stop
}

#define macro _DEPOSIT_AMOUNT_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload   // [amount]

    // -- Verify `amount` Against Free Balance
    [TOTAL_SUPPLY_SLOT] // [total_supply.slot, amount]
    dup1 sload          // [total_supply, total_supply.slot, amount]
    dup1                // [total_supply, total_supply, total_supply.slot, amount]
    selfbalance sub     // [avail_amount, total_supply, total_supply.slot, amount]

    dup4                // [amount, avail_amount, total_supply, total_supply.slot, amount]
    gt insufficent_free_balance_error jumpi
    //                     [total_supply, total_supply.slot, amount]

    // -- Update Caller's Balance
    caller sload        // [msg.sender.bal, total_supply, total_supply.slot, amount]
    dup4 add            // [msg.sender.bal', total_supply, total_supply.slot, amount]
    caller sstore       // [total_supply, total_supply.slot, amount]

    // -- Update Total Supply
    dup3                // [amount, total_supply, total_supply.slot, amount]
    add                 // [total_supply', total_supply.slot, amount]
    swap1 sstore        // [amount]

    // -- Emit Transfer Event
    <zero> mstore       // []
    caller <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, msg.sender]
    0x20 <zero> log3    // []

    stop
}

#define macro _DEPOSIT_AMOUNT_TO_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 LOAD_ADDRESS() // [to]
    0x24 calldataload   // [amount, to]

    // -- Verify `amount` Against Free Balance
    [TOTAL_SUPPLY_SLOT] // [total_supply.slot, amount, to]
    dup1 sload          // [total_supply, total_supply.slot, amount, to]
    dup1                // [total_supply, total_supply, total_supply.slot, amount, to]
    selfbalance sub     // [avail_amount, total_supply, total_supply.slot, amount, to]

    dup4                // [amount, avail_amount, total_supply, total_supply.slot, amount, to]
    gt insufficent_free_balance_error jumpi
    //                     [total_supply, total_supply.slot, amount, to]

    // -- Update Caller's Balance
    dup4 sload          // [to.data, total_supply, total_supply.slot, amount, to]
    dup4 add            // [to.data', total_supply, total_supply.slot, amount, to]
    dup5 sstore         // [total_supply, total_supply.slot, amount, to]

    // -- Update Total Supply
    dup3                // [amount, total_supply, total_supply.slot, amount, to]
    add                 // [total_supply', total_supply.slot, amount, to]
    swap1 sstore        // [amount, to]

    // -- Emit Transfer Event
    <zero> mstore       // [to]
    <zero> __EVENT_HASH(Transfer)
    //                     [Transfer.sig, 0, to]
    0x20 <zero> log3    // []

    stop
}

#define macro BURN_FROM_CALLER(zero) = takes(1) returns(0) {
    // takes:                [amount]

    // -- Update Balance
    dup1                  // [amount, amount]
    caller sload          // [msg.sender.data, amount, amount]
    dup1                  // [msg.sender.data, msg.sender.data, amount, amount]
    [BALANCE_MASK] and    // [msg.sender.bal, msg.sender.data, amount, amount]
    dup3                  // [amount, msg.sender.bal, msg.sender.data, amount, amount]
    gt insufficient_bal_error jumpi
    //                       [msg.sender.data, amount, amount]
    sub                   // [msg.sender.data', amount]
    caller sstore         // [amount]

    // -- Update Total Supply
    [TOTAL_SUPPLY_SLOT]   // [total_supply.slot, amount]
    dup2 dup2             // [total_supply.slot, amount, total_supply.slot, amount]
    sload sub             // [total_supply', total_supply.slot, amount]
    swap1 sstore          // [amount]

    // -- Emit Transfer
    <zero> mstore         // [amount]
    <zero> caller __EVENT_HASH(Transfer)
    //                       [Transfer.sig, msg.sender, 0]
    0x20 <zero> log3      // []

    // returns:              []
}

#define macro _WITHDRAW_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 calldataload                // [amount]
    dup1                             // [amount, amount]
    BURN_FROM_CALLER(<zero>)         // [amount]
    SEND_ETH_TO_CALLER(<zero>, 0x00) // []
    stop
}

#define macro _WITHDRAW_TO_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 LOAD_ADDRESS()           // [recipient]
    0x24 calldataload             // [amount, recipient]
    dup1 BURN_FROM_CALLER(<zero>) // [amount, recipient]
    SEND_ETH(<zero>, 0x00)
    stop
}

#define macro BURN_FROM(zero) = takes(2) returns(0) {
    // takes:                [amount, from]

    // -- Update Balance
    dup1                  // [amount, amount, from]
    dup3 sload            // [from.data, amount, amount, from]
    dup1                  // [from.data, from.data, amount, amount]
    [BALANCE_MASK] and    // [from.bal, from.data, amount, amount]
    dup3                  // [amount, from.bal, from.data, amount, amount]
    gt insufficient_bal_error jumpi
    //                       [from.data, amount, amount, from]
    sub                   // [from.data', amount, from]
    dup3 sstore           // [amount, from]

    // -- Update Total Supply
    [TOTAL_SUPPLY_SLOT]   // [total_supply.slot, amount, from]
    dup2 dup2             // [total_supply.slot, amount, total_supply.slot, amount, from]
    sload sub             // [total_supply', total_supply.slot, amount, from]
    swap1 sstore          // [amount, from]

    // -- Emit Transfer
    <zero> mstore         // [from]
    <zero> swap1 __EVENT_HASH(Transfer)
    //                       [Transfer.sig, from, 0]
    0x20 <zero> log3      // []

    // returns:              []
}

#define macro WITHDRAW_FROM_END(zero, zero2) = takes(3) returns(0) {
    // takes:                              [amount, from, amount]

    BURN_FROM(<zero>)                   // [amount]
    SEND_ETH_TO_CALLER(<zero>, <zero2>) // []
    stop
}

#define macro _WITHDRAW_FROM_EXTERNAL(zero) = takes(0) returns(0) {
    0x24 calldataload       // [amount]
    0x04 LOAD_ADDRESS()     // [from, amount]
    dup2                    // [amount, from, amount]

    USE_ALLOWANCE(<zero>, withdraw_from_allowed_2pop)
        //                     [amount, from, amount]
        WITHDRAW_FROM_END(<zero>, 0x00)
    withdraw_from_allowed_2pop:
        pop pop             // [amount, from, amount]
        WITHDRAW_FROM_END(<zero>, 0x00)
}

#define macro WITHDRAW_FROM_TO_END(zero, zero2) = takes(4) returns(0) {
    // takes:                              [amount, from, amount, to]

    BURN_FROM(<zero>)                   // [amount, to]
    SEND_ETH(<zero>, <zero2>)           // []
    stop
}

#define macro _WITHDRAW_FROM_TO_EXTERNAL(zero) = takes(0) returns(0) {
    0x24 calldataload       // [to]
    0x44 calldataload       // [amount, to]
    0x04 calldataload       // [from, amount, to]
    dup3 dup2 or REQUIRE_ADDRESS()
    //                         [from, amount, to]
    dup2                    // [amount, from, amount, to]

    USE_ALLOWANCE(<zero>, withdraw_from_to_allowed_2pop)
        //                     [amount, from, amount, to]
        WITHDRAW_FROM_TO_END(<zero>, 0x00)
    withdraw_from_to_allowed_2pop:
        pop pop             // [amount, from, amount, to]
        WITHDRAW_FROM_TO_END(<zero>, 0x00)
}

#define macro IS_FORK() = takes(0) returns(1) {
    [MAINNET_CHAIN_ID] chainid sub
}

#define macro _DOMAIN_SEPARATOR_EXTERNAL(zero) = takes(0) returns(0) {
    IS_FORK() BRANCHLESS_ASSERT_ZERO()
    [CACHED_DOMAIN_SEPARATOR] RETURN_WORD(<zero>)
}

#define macro _NONCES_EXTERNAL(zero) = takes(0) returns(0) {
    0x04 LOAD_ADDRESS() // [account]
    sload               // [account.data]
    [NONCE_SHIFT] shr   // [account.nonce]
    RETURN_WORD(<zero>)
}

#define jumptable__packed FN_TABLE {
    depositAmountTo_dest nonces_dest withdrawFrom_dest deposit_dest depositAmount_dest symbol_dest no_selector_match withdraw_dest balanceOf_dest no_selector_match withdrawTo_dest decimals_dest name_dest no_selector_match no_selector_match no_selector_match no_selector_match approve_dest no_selector_match DOMAIN_SEPARATOR_dest withdrawFromTo_dest transferFrom_dest no_selector_match no_selector_match transfer_dest depositTo_dest permit_dest no_selector_match allowance_dest totalSupply_dest no_selector_match multicall_dest
}

#define macro _MAIN(zero) = takes(0) returns(0) {
    <zero> calldataload // [cd[0]]
    // -- store selector
    dup1 msize mstore   // [cd[0]]
    // -- store nonce (also clears non-selector calldata)
    0x574 0x4 mstore
    // jump label size
    0x2                 // [2, cd[0]]
    // -- get function index
    msize <zero> sha3 0x3e and
    //                     [function_index << 1, 2, cd[0]]
    // -- load jump label
    __tablestart(FN_TABLE) add
    0x5e codecopy       // [cd[0]]
    0xe0 shr            // [selector]
    0x40 mload          // [jump_loc, selector]
    // -- use jump label
    jump

    name_dest:
        dup1 __FUNC_SIG(name)               sub no_selector_match jumpi
        _NAME_EXTERNAL(<zero>)
    symbol_dest:
        dup1 __FUNC_SIG(symbol)             sub no_selector_match jumpi
        _SYMBOL_EXTERNAL(<zero>)
    decimals_dest:
        dup1 __FUNC_SIG(decimals)           sub no_selector_match jumpi
        _DECIMALS_EXTERNAL(<zero>)
    totalSupply_dest:
        dup1 __FUNC_SIG(totalSupply)        sub no_selector_match jumpi
        _TOTAL_SUPPLY_EXTERNAL(<zero>)
    transferFrom_dest:
        dup1 __FUNC_SIG(transferFrom)       sub no_selector_match jumpi
        _TRANSFER_FROM_EXTERNAL(<zero>)
    transfer_dest:
        dup1 __FUNC_SIG(transfer)           sub no_selector_match jumpi
        _TRANSFER_EXTERNAL(<zero>)
    balanceOf_dest:
        dup1 __FUNC_SIG(balanceOf)          sub no_selector_match jumpi
        _BALANCE_OF_EXTERNAL(<zero>)
    approve_dest:
        dup1 __FUNC_SIG(approve)            sub no_selector_match jumpi
        _APPROVE_EXTERNAL(<zero>)
    allowance_dest:
        dup1 __FUNC_SIG(allowance)          sub no_selector_match jumpi
        _ALLOWANCE_EXTERNAL(<zero>)
    deposit_dest:
        dup1 __FUNC_SIG(deposit)            sub no_selector_match jumpi
        _DEPOSIT_EXTERNAL(<zero>)
    depositTo_dest:
        dup1 __FUNC_SIG(depositTo)          sub no_selector_match jumpi
        _DEPOSIT_TO_EXTERNAL(<zero>)
    depositAmountTo_dest:
        dup1 __FUNC_SIG(depositAmountTo)    sub no_selector_match jumpi
        _DEPOSIT_AMOUNT_TO_EXTERNAL(<zero>)
    depositAmount_dest:
        dup1 __FUNC_SIG(depositAmount)      sub no_selector_match jumpi
        _DEPOSIT_AMOUNT_EXTERNAL(<zero>)
    withdraw_dest:
        dup1 __FUNC_SIG(withdraw)           sub no_selector_match jumpi
        _WITHDRAW_EXTERNAL(<zero>)
    withdrawTo_dest:
        dup1 __FUNC_SIG(withdrawTo)         sub no_selector_match jumpi
        _WITHDRAW_TO_EXTERNAL(<zero>)
    withdrawFrom_dest:
        dup1 __FUNC_SIG(withdrawFrom)       sub no_selector_match jumpi
        _WITHDRAW_FROM_EXTERNAL(<zero>)
    withdrawFromTo_dest:
        dup1 __FUNC_SIG(withdrawFromTo)     sub no_selector_match jumpi
        _WITHDRAW_FROM_TO_EXTERNAL(<zero>)
    DOMAIN_SEPARATOR_dest:
        dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   sub no_selector_match jumpi
        _DOMAIN_SEPARATOR_EXTERNAL(<zero>)
    nonces_dest:
        dup1 __FUNC_SIG(nonces)             sub no_selector_match jumpi
        _NONCES_EXTERNAL(<zero>)
    permit_dest:
        dup1 __FUNC_SIG(permit)             sub no_selector_match jumpi
    multicall_dest:
        dup1 __FUNC_SIG(multicall)          sub no_selector_match jumpi
    no_selector_match:
        // `receive()` fallback method, skips to revert if any calldata was sent
        calldatasize empty_revert jumpi
        _DEPOSIT_EXTERNAL(<zero>)
        empty_revert:
            0x00 0x00 revert

    insufficient_bal_error:
        __FUNC_SIG(InsufficientBalance) REVERT(<zero>)
    insufficient_allowance_error:
        __FUNC_SIG(InsufficientAllowance) REVERT(<zero>)
    insufficent_free_balance_error:
        __FUNC_SIG(InsufficientFreeBalance) REVERT(<zero>)

}

#define macro COMPUTE_ERC712_DOMAIN_SEPARATOR(zero) = takes(0) returns(1) {
    [ERC712_DOMAIN_HASH] <zero> mstore
    [NAME_HASH]           0x20  mstore
    [VERSION_HASH]        0x40  mstore
    chainid               0x60  mstore
    address               0x80  mstore
    0xa0 <zero> sha3
}

#define macro CONSTRUCTOR() = takes(0) returns(0) {
    // Check that placeholder domain separator was replaced and correctly computed
        COMPUTE_ERC712_DOMAIN_SEPARATOR(returndatasize) [CACHED_DOMAIN_SEPARATOR] sub
        IS_FORK()
    or
    BRANCHLESS_ASSERT_ZERO()
}

#define macro MAIN() = takes(0) returns(0) {
  _MAIN(returndatasize)
}
