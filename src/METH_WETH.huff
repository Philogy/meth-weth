#include "./interfaces/IMETH.huff"

////////////////////////////////////////////////////////////////
//                   BASE CONSTANTS                           //
////////////////////////////////////////////////////////////////
/// @notice If changed for alternative chain, replace use of `CHAINID` as "push 1" in `permit`.
#define constant INF_ALLOW_LIM = 0xfeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
#define constant MAX_ADDR = 0xffffffffffffffffffffffffffffffffffffffff

////////////////////////////////////////////////////////////////
//             SELECTOR SWITCH CONSTANTS                      //
////////////////////////////////////////////////////////////////
/// @dev Right bit shift that retrieves the unique upper bits of all selectors contained within the ABI.
#define constant S_SHIFT = 0x14 // 20
#define constant S_COVER = 0x0f // 15 (1111_2)

////////////////////////////////////////////////////////////////
//                 METADATA CONSTANTS                         //
////////////////////////////////////////////////////////////////
// ================== Decimals ===================
/// @dev METH has 18 decimals meaning a balance of `1120000000000000000` should be displayed as `1.12`.
#define constant DECIMALS = 0x12
// ==================== Name =====================
// name.length ++ "M"
#define constant PACKED_NAME_1        = 0x214d
#define constant PACKED_NAME_OFFSET_1 = 0x21
// "aximally Efficient Wrapped Ether"
#define constant PACKED_NAME_2        = 0x6178696d616c6c7920456666696369656e742057726170706564204574686572
#define constant PACKED_NAME_OFFSET_2 = 0x41
// =================== Symbol ====================
// symbol.length ++ "METH"
#define constant PACKED_SYMBOL_1 = 0x044d455448
#define constant PACKED_SYMBOL_OFFSET_1 = 0x24

/// @dev The only special privileges the recovery address should have is the ability to sweep funds from the zero and this addresses.
#define constant RECOVERY_ADDR = 0x1212121212121212121212121212121212121212

#define macro _REQUIRE_NOT_ZERO() = takes(1) returns(1) {
    // takes:         [to]
    dup1           // [to, to]
    not_zero jumpi // [to]
        __FUNC_SIG(RecipientZero) _REVERT()
    not_zero:      // [to]
    // returns:       [to]
}

#define macro _LOAD_ADDRESS() = takes(1) returns(1) {
    // takes:             [calldata_pos]
    calldataload       // [addr_raw]
    [MAX_ADDR] and     // [addr]
    // returns:        // [addr]
}

#define macro _REVERT() = takes(1) returns(0) {
    push0 mstore
    0x04 0x1c revert
}

#define macro _RETURN_WORD(word_size) = takes(1) returns(0) {
    // takes:                   [x]
                push0 mstore // []
    <word_size> push0 return // []
}

#define macro _RETURN_TRUE(word_size) = takes(0) returns(0) {
    0x1 _RETURN_WORD(<word_size>)
}

#define macro _BUBBLE_REVERT() = takes(1) returns(0) {
    // takes:             [success]
    no_bubble jumpi
        returndatasize push0 push0 returndatacopy
        returndatasize push0 revert
    no_bubble:
}

#define macro _PUSH_4_ZEROS() = takes(0) returns(4) {
    push0 push0 push0 push0     // [0, 0, 0, 0]
}

#define macro _SEND_ETH() = takes(6) returns(0) {
    // takes:                [recipient, amount, 0, 0, 0, 0]
    gas call              // [success]
    _BUBBLE_REVERT()      // []
    // returns:              []
}

#define macro _EMIT_TRANSFER(word_size) = takes(3) returns(0) {
    // takes:                 [amount, from, to]
    push0 mstore           // [from, to]
    __EVENT_HASH(Transfer) // [Transfer.sig, from, to]
    <word_size> push0 log3
}

#define macro _TRANSFER(word_size) = takes(5) returns(0) {
    // takes:                  [from, amount, amount, from, to]

    // -- Update `from` Balance
    sload dup1              // [from.bal, from.bal, amount, amount, from, to]
    dup3                    // [amount, from.bal, from.bal, amount, amount, from, to]
    gt insufficient_bal_error jumpi
    //                         [from.bal, amount, amount, from, to]
    sub                     // [from.bal', amount, from, to]
    dup3 sstore             // [amount, from, to]

    // -- Update `to` Balance
    dup3 sload              // [to.bal, amount, from, to]
    dup2 add                // [to.bal', amount, from, to]
    dup4 sstore             // [amount, from, to]

    _EMIT_TRANSFER(<word_size>)
}

#define macro _WITHDRAW_ALL() = takes(0) returns(1) {
    // takes:                          []
    // -- Update balance.
    caller sload                    // [msg.sender.bal]
    push0 caller sstore             // [msg.sender.bal]
    // -- Get amount and emit event.
    caller dup2                     // [amount, caller, amount]
    _EMIT_WITHDRAWAL(msize)         // [amount]
    // returns:                        [amount]
}

// -- External Functions
// ---- Metadata / Global Methods
#define macro NAME() = takes(0) returns(0) {
    // Store string offset.
    0x20            push0                mstore
    // Write packed string data to memory, including length.
    [PACKED_NAME_1] [PACKED_NAME_OFFSET_1] mstore
    [PACKED_NAME_2] [PACKED_NAME_OFFSET_2] mstore
    msize           push0                 return
}

#define macro SYMBOL() = takes(0) returns(0) {
    0x20              push0                    mstore
    [PACKED_SYMBOL_1] [PACKED_SYMBOL_OFFSET_1] mstore
    msize             push0                    return
}

#define macro DECIMALS() = takes(0) returns(0) {
    [DECIMALS] _RETURN_WORD(msize)
}

#define macro TOTAL_SUPPLY() = takes(0) returns(0) {
    selfbalance _RETURN_WORD(msize)
}

// ---- Transfer related methods
#define macro BALANCE_OF() = takes(0) returns(0) {
    0x04 _LOAD_ADDRESS()   // [account]
    sload                  // [account.bal]
    _RETURN_WORD(msize)
}

#define macro TRANSFER() = takes(0) returns(0) {
    0x04 _LOAD_ADDRESS()  // [to]
    caller                // [msg.sender, to]
    0x24 calldataload     // [amount, msg.sender, to]
    dup1 caller           // [msg.sender, amount, amount, msg.sender, to]
    _TRANSFER(msize)

    _RETURN_TRUE(msize)
}

#define macro _APPROVE() = takes(0) returns(0) {
    // -- Load & Verify Params
    0x04 _LOAD_ADDRESS()   // [spender]
    0x24 calldataload      // [amount, spender]

    // -- Store approval
    caller msize  mstore   // [amount, spender]
    dup2   msize  mstore   // [amount, spender]
    dup1                   // [amount, amount, spender]
    0x40 push0 sha3        // [allowance.slot, amount, amount, spender]
    sstore                 // [amount, spender]

    // -- Emit Event
    push0 mstore           // [spender]
    caller                 // [owner, spender]
    __EVENT_HASH(Approval) // [Approval.sig, owner, spender]
    0x20 push0 log3        // []
}

#define macro APPROVE() = takes(0) returns(0) {
    _APPROVE()
    _RETURN_TRUE(0x20)
}

#define macro ALLOWANCE() = takes(0) returns(0) {
    0x24 calldataload  // [spender]
    0x04 calldataload  // [owner, spender]
    msize mstore       // [spender]
    msize mstore       // []
    msize push0 sha3   // [allowance.slot]
    sload              // [allowance]
    _RETURN_WORD(0x20)
}


// Actually "returns" 4 if jumping to `use_allowance_2pop`
/// @dev Checks and updates `from`'s allowance to caller
#define macro _USE_ALLOWANCE(use_allowance_2pop) = takes(2) returns(2) {
    // takes:               [amount, from]
    dup2   msize  mstore // [amount, from]
    caller msize  mstore // [amount, from]
    msize  push0 sha3    // [allowance.slot, amount, from]
    dup1 sload           // [allowance, allowance.slot, amount, from]
    dup1 [INF_ALLOW_LIM] // [inf_allow_lim, allowance, allowance, allowance.slot, amount, from]
    lt <use_allowance_2pop> jumpi
    //                      [allowance, allowance.slot, amount, from]
    dup1 dup4            // [amount, allowance, allowance, allowance.slot, amount, from]
    gt insufficient_allowance_error jumpi
    //                      [allowance, allowance.slot, amount, from]
    dup3 swap1 sub       // [allowance', allowance.slot, amount, from]
    swap1 sstore         // [amount, from]
}

#define macro _TRANSFER_FROM_END(word_size) = takes(3) returns(0) {
    // takes:             [amount, from, to]
    dup1 dup3          // [from, amount, amount, from, to]
    _TRANSFER(<word_size>)
    _RETURN_TRUE(<word_size>)
}

#define macro TRANSFER_FROM() = takes(0) returns(0) {
    // -- Load & Verify Params.
    0x24 _LOAD_ADDRESS()  // [to]
    0x04 _LOAD_ADDRESS()  // [from, to]
    0x44 calldataload     // [amount, from, to]

    // -- Verify Allowance
    _USE_ALLOWANCE(transfer_from_allowed_2pop)
        //                  [amount, from, to]
        _TRANSFER_FROM_END(0x20)
    transfer_from_allowed_2pop:
        //                  [_, _, amount, from, to]
        pop pop          // [amount, from, to]
        _TRANSFER_FROM_END(0x20)
}

#define macro _EMIT_DEPOSIT(word_size) = takes(1) returns(0) {
    // takes:                 [to]
    callvalue push0 mstore // [to]
    __EVENT_HASH(Deposit)  // [Deposit.sig, to]
    <word_size> push0 log2 // []
}

#define macro _DEPOSIT() = takes(0) returns(0) {
    caller sload            // [msg.sender.bal]
    // Would need 3.4 x 10^20 ETH to overflow into nonce.
    callvalue add           // [msg.sender.bal']
    caller sstore           // []
    caller _EMIT_DEPOSIT(msize)
}

#define macro DEPOSIT() = takes(0) returns(0) {
    _DEPOSIT()
    stop
}

#define macro DEPOSIT_TO() = takes(0) returns(0) {
    // -- Load params.
    0x04 _LOAD_ADDRESS()    // [to]
    dup1 sload              // [to.bal, to]
    // Would need 3.4 x 10^20 ETH to overflow into nonce.
    callvalue add           // [to.bal', to]
    dup2 sstore             // [to]
    _EMIT_DEPOSIT(msize)
    stop
}

#define macro DEPOSIT_AND_APPROVE() = takes(0) returns(0) {
    _DEPOSIT()
    _APPROVE()
    stop
}

#define macro _EMIT_WITHDRAWAL(word_size) = takes(2) returns(0) {
    // takes:                   [amount, from]
    push0 mstore             // [from]
    __EVENT_HASH(Withdrawal) // [Withdrawal.sig, from]
    <word_size> push0 log2   // []
}

#define macro _BURN_FROM_CALLER() = takes(2) returns(0) {
    // takes:                [amount, msg.sender]

    // -- Update Balance
    dup1                  // [amount, amount, msg.sender]
    caller sload          // [msg.sender.bal, amount, amount, msg.sender]
    dup1                  // [msg.sender.bal, msg.sender.bal, amount, amount, msg.sender]
    dup3                  // [amount, msg.sender.bal, msg.sender.bal, amount, amount, msg.sender]
    gt insufficient_bal_error jumpi
    //                       [msg.sender.bal, amount, amount, msg.sender]
    sub                   // [msg.sender.bal', amount, msg.sender]
    caller sstore         // [amount, msg.sender]

    _EMIT_WITHDRAWAL(msize)
}

#define macro WITHDRAW() = takes(0) returns(0) {
    _PUSH_4_ZEROS()     // [0, 0, 0, 0]
    0x04 calldataload   // [amount, 0, 0, 0, 0]
    caller dup2         // [amount, msg.sender, amount, 0, 0, 0, 0]
    _BURN_FROM_CALLER() // [amount, 0, 0, 0, 0]
    caller              // [msg.sender, amount, 0, 0, 0, 0]
    _SEND_ETH()         // []
    stop
}

#define macro WITHDRAW_TO() = takes(0) returns(0) {
    // -- Setup stack.
    _PUSH_4_ZEROS()     // [0, 0, 0, 0]
    0x24 calldataload   // [amount, 0, 0, 0, 0]
    caller dup2         // [amount, msg.sender, amount, 0, 0, 0, 0]
    // -- Update balance and emit event.
    _BURN_FROM_CALLER() // [amount, 0, 0, 0, 0]
    // -- Transfer ETH
    0x04 calldataload   // [to, amount, 0, 0, 0, 0]
    _SEND_ETH()         // []
    stop
}

#define macro WITHDRAW_ALL() = takes(0) returns(0) {
    // -- Setup stack.
    _PUSH_4_ZEROS() // [0, 0, 0, 0]
    // -- Update balance and emit event.
    _WITHDRAW_ALL() // [amount, 0, 0, 0, 0]
    // -- Transfer ETH.
    caller          // [msg.sender, amount, 0, 0, 0, 0]
    _SEND_ETH()     // []
    stop
}

#define macro WITHDRAW_ALL_TO() = takes(0) returns(0) {
    // Push zeros before to avoid swaps later.
    _PUSH_4_ZEROS()     // [0, 0, 0, 0]
    // -- Update balance and emit event.
    _WITHDRAW_ALL()     // [amount, 0, 0, 0, 0]
    // -- Transfer ETH.
    0x04 calldataload   // [to, amount, 0, 0, 0, 0]
    _REQUIRE_NOT_ZERO() // [to, amount, 0, 0, 0, 0]
    _SEND_ETH()         // []
    stop
}

#define macro _BURN_FROM() = takes(2) returns(0) {
    // takes:                   [amount, from]

    // -- Update Balance
    dup1                     // [amount, amount, from]
    dup3 sload               // [from.bal, amount, amount, from]
    dup1                     // [from.bal, from.bal, amount, amount]
    dup3                     // [amount, from.bal, from.bal, amount, amount]
    gt insufficient_bal_error jumpi
    //                          [from.bal, amount, amount, from]
    sub                      // [from.bal', amount, from]
    dup3 sstore              // [amount, from]

    // -- Emit Withdrawal
    push0 mstore             // [from]
    __EVENT_HASH(Withdrawal) // [Transfer.sig, from]
    0x20 push0 log2          // []

    // returns:                 []
}

#define macro _WITHDRAW_FROM() = takes(7) returns(0) {
    // takes:        [amount, from, amount, 0, 0, 0, 0]

    _BURN_FROM()  // [amount, 0, 0, 0, 0]
    caller        // [msg.sender, amount, 0, 0, 0, 0]
    _SEND_ETH()   // []
}

#define macro WITHDRAW_FROM() = takes(0) returns(0) {
    // -- Load & Verify Params.
    _PUSH_4_ZEROS()    // [0, 0, 0, 0]
    0x24 calldataload       // [amount, 0, 0, 0, 0]
    0x04 calldataload       // [from, amount, 0, 0, 0, 0]
    dup2                    // [amount, from, amount, 0, 0, 0, 0]

    _USE_ALLOWANCE(withdraw_from_allowed_2pop)
        //                     [amount, from, amount, 0, 0, 0, 0]
        _WITHDRAW_FROM()
        stop
    withdraw_from_allowed_2pop:
        //                     [_, _, amount, from, amount, 0, 0, 0, 0]
        pop pop             // [amount, from, amount, 0, 0, 0, 0]
        _WITHDRAW_FROM()
        stop
}

#define macro _WITHDRAW_FROM_TO() = takes(7) returns(0) {
    // takes:               [amount, from, amount, 0, 0, 0, 0]

    _BURN_FROM()         // [amount, 0, 0, 0, 0]
    0x24 calldataload    // [to, amount, 0, 0, 0, 0]
    _SEND_ETH()          // []
}

#define macro WITHDRAW_FROM_TO() = takes(0) returns(0) {
    // Load & Verify Params.

    _PUSH_4_ZEROS()         // [0, 0, 0, 0]
    0x04 calldataload       // [from, 0, 0, 0, 0]
    0x44 calldataload       // [amount, from, 0, 0, 0, 0]
    dup2                    // [amount, from, amount, 0, 0, 0, 0]

    _USE_ALLOWANCE(withdraw_from_to_allowed_2pop)
        //                     [amount, from, amount, 0, 0, 0, 0]
        _WITHDRAW_FROM_TO() // []
        stop
    withdraw_from_to_allowed_2pop:
        //                     [_, _, amount, from, amount, 0, 0, 0, 0]
        pop pop             // [amount, from, amount, 0, 0, 0, 0]
        _WITHDRAW_FROM_TO() // []
        stop
}

#define macro RESCUE_LOST() = takes(0) returns(0) {
    // Load lost tokens.
    push0 sload                  // [0.bal]
    address sload                // [this.balance, 0.bal]
    // Emit Transfer events.
    [RECOVERY_ADDR] push0 dup4   // [0.bal, 0, recovery_addr, this.balance, 0.bal]
    _EMIT_TRANSFER(msize)        // [this.balance, 0.bal]
    [RECOVERY_ADDR] address dup3 // [this.balance, this, recovery_addr, this.balance, 0.bal]
    _EMIT_TRANSFER(msize)        // [this.balance, 0.bal]
    // Increase the balance of the rescue address.
    add                          // [total_lost]
    [RECOVERY_ADDR] sload        // [recovery_addr.bal, total_lost]
    add                          // [recovery_addr.bal']
    [RECOVERY_ADDR] sstore       // []
    // Reset balance of "lost accounts" to 0.
    push0 push0  sstore          // []
    push0 address sstore         // []
    // Send ETH to rescue address
    stop
}

#define macro __SELECTOR() = takes(0) returns(1) {
    push0 calldataload 0xe0 shr
}

#define macro __PAYABLE_FUNC_CHECK(selector, final_dest) = takes(1) returns(0) {
    <selector> eq <final_dest> jumpi
    push0 push0 revert
    // Padding to make sure block is 16 bytes large post compilation.
    stop stop
    /*
    JUMPDEST          PUSH4             SELECTOR_BYTE_1   SELECTOR_BYTE_2
    SELECTOR_BYTE_3   SELECTOR_BYTE_4   EQ                PUSH2
    DEST_BYTE_1       DEST_BYTE_2       JUMPI             PUSH0
    PUSH0             REVERT            STOP              STOP
    */
}

#define macro __NON_PAYABLE_FUNC_CHECK(selector, final_dest) = takes(1) returns(0) {
    <selector> eq callvalue lt <final_dest> jumpi
    push0 push0 revert
    /*
    No padding as non-payable check block is exactly 16-bytes large post-compile:
    JUMPDEST          PUSH4             SELECTOR_BYTE_1   SELECTOR_BYTE_2
    SELECTOR_BYTE_3   SELECTOR_BYTE_4   EQ                CALLVALUE
    LT                PUSH2             DEST_BYTE_1       DEST_BYTE_2
    JUMPI             PUSH0             PUSH0             REVERT
    */
}

#define macro __NO_MATCH() = takes(0) returns(0) {
    push0 push0 revert
    // Padding to make sure block is 16 bytes large post compilation.
    stop stop stop stop
    stop stop stop stop
    stop stop stop stop
    /*
    JUMPDEST          PUSH0             PUSH0             REVERT
    STOP              STOP              STOP              STOP
    STOP              STOP              STOP              STOP
    STOP              STOP              STOP              STOP
    */
}

#define macro __RECEIVE_CHECK(deposit_dest) = takes(0) returns(0) {
    calldatasize iszero <deposit_dest> jumpi
    push0 push0 revert
    // Padding to make sure block is 16 bytes large post compilation.
    stop stop stop stop stop stop
    /*
    JUMPDEST          CALLDATASIZE      ISZERO            PUSH2
    DEST_BYTE_1       DEST_BYTE_2       JUMPI             PUSH0
    PUSH0             REVERT            STOP              STOP
    STOP              STOP              STOP              STOP
    */
}

#define macro MAIN() = takes(0) returns(0) {
    // Load selector.
    __SELECTOR()
    // Isolate unique selector bits.
    dup1 [S_SHIFT] shr
    // Set lower bits to 1 to ensure alternative selectors also jump to valid destinations.
    [S_COVER] or
    jump

    // Padding to make sure jump dests start at the right offset.
    stop stop

    dest_0x00f: __RECEIVE_CHECK(deposit_final_dest)
    dest_0x01f: __NO_MATCH()
    dest_0x02f: __NO_MATCH()
    dest_0x03f: __NO_MATCH()
    dest_0x04f: __NO_MATCH()
    dest_0x05f: __NO_MATCH()
    dest_0x06f: __NON_PAYABLE_FUNC_CHECK(0x06fdde03, name_final_dest)
    dest_0x07f: __NO_MATCH()
    dest_0x08f: __NO_MATCH()
    dest_0x09f: __NON_PAYABLE_FUNC_CHECK(0x095ea7b3, approve_final_dest)
    dest_0x0af: __NO_MATCH()
    dest_0x0bf: __NO_MATCH()
    dest_0x0cf: __NO_MATCH()
    dest_0x0df: __NO_MATCH()
    dest_0x0ef: __NO_MATCH()
    dest_0x0ff: __NO_MATCH()
    dest_0x10f: __NO_MATCH()
    dest_0x11f: __NO_MATCH()
    dest_0x12f: __NO_MATCH()
    dest_0x13f: __NO_MATCH()
    dest_0x14f: __NO_MATCH()
    dest_0x15f: __NO_MATCH()
    dest_0x16f: __NO_MATCH()
    dest_0x17f: __NO_MATCH()
    dest_0x18f: __NON_PAYABLE_FUNC_CHECK(0x18160ddd, totalSupply_final_dest)
    dest_0x19f: __NO_MATCH()
    dest_0x1af: __NO_MATCH()
    dest_0x1bf: __NO_MATCH()
    dest_0x1cf: __NO_MATCH()
    dest_0x1df: __NO_MATCH()
    dest_0x1ef: __NO_MATCH()
    dest_0x1ff: __NO_MATCH()
    dest_0x20f: __NON_PAYABLE_FUNC_CHECK(0x205c2878, withdrawTo_final_dest)
    dest_0x21f: __NO_MATCH()
    dest_0x22f: __NO_MATCH()
    dest_0x23f: __NON_PAYABLE_FUNC_CHECK(0x23b872dd, transferFrom_final_dest)
    dest_0x24f: __NO_MATCH()
    dest_0x25f: __NO_MATCH()
    dest_0x26f: __NO_MATCH()
    dest_0x27f: __NO_MATCH()
    dest_0x28f: __PAYABLE_FUNC_CHECK(0x28026ace, depositAndApprove_final_dest)
    dest_0x29f: __NO_MATCH()
    dest_0x2af: __NO_MATCH()
    dest_0x2bf: __NO_MATCH()
    dest_0x2cf: __NO_MATCH()
    dest_0x2df: __NO_MATCH()
    dest_0x2ef: __NON_PAYABLE_FUNC_CHECK(0x2e1a7d4d, withdraw_final_dest)
    dest_0x2ff: __NO_MATCH()
    dest_0x30f: __NO_MATCH()
    dest_0x31f: __NON_PAYABLE_FUNC_CHECK(0x313ce567, decimals_final_dest)
    dest_0x32f: __NO_MATCH()
    dest_0x33f: __NO_MATCH()
    dest_0x34f: __NO_MATCH()
    dest_0x35f: __NO_MATCH()
    dest_0x36f: __NO_MATCH()
    dest_0x37f: __NO_MATCH()
    dest_0x38f: __NO_MATCH()
    dest_0x39f: __NO_MATCH()
    dest_0x3af: __NO_MATCH()
    dest_0x3bf: __NO_MATCH()
    dest_0x3cf: __NO_MATCH()
    dest_0x3df: __NO_MATCH()
    dest_0x3ef: __NO_MATCH()
    dest_0x3ff: __NO_MATCH()
    dest_0x40f: __NO_MATCH()
    dest_0x41f: __NO_MATCH()
    dest_0x42f: __NO_MATCH()
    dest_0x43f: __NO_MATCH()
    dest_0x44f: __NO_MATCH()
    dest_0x45f: __NO_MATCH()
    dest_0x46f: __NON_PAYABLE_FUNC_CHECK(0x4648b24c, rescueLost_final_dest)
    dest_0x47f: __NO_MATCH()
    dest_0x48f: __NO_MATCH()
    dest_0x49f: __NO_MATCH()
    dest_0x4af: __NON_PAYABLE_FUNC_CHECK(0x4a4089cc, withdrawFromTo_final_dest)
    dest_0x4bf: __NO_MATCH()
    dest_0x4cf: __NO_MATCH()
    dest_0x4df: __NO_MATCH()
    dest_0x4ef: __NO_MATCH()
    dest_0x4ff: __NO_MATCH()
    dest_0x50f: __NO_MATCH()
    dest_0x51f: __NO_MATCH()
    dest_0x52f: __NO_MATCH()
    dest_0x53f: __NO_MATCH()
    dest_0x54f: __NO_MATCH()
    dest_0x55f: __NO_MATCH()
    dest_0x56f: __NO_MATCH()
    dest_0x57f: __NO_MATCH()
    dest_0x58f: __NO_MATCH()
    dest_0x59f: __NO_MATCH()
    dest_0x5af: __NO_MATCH()
    dest_0x5bf: __NO_MATCH()
    dest_0x5cf: __NO_MATCH()
    dest_0x5df: __NO_MATCH()
    dest_0x5ef: __NO_MATCH()
    dest_0x5ff: __NO_MATCH()
    dest_0x60f: __NO_MATCH()
    dest_0x61f: __NO_MATCH()
    dest_0x62f: __NO_MATCH()
    dest_0x63f: __NO_MATCH()
    dest_0x64f: __NO_MATCH()
    dest_0x65f: __NO_MATCH()
    dest_0x66f: __NO_MATCH()
    dest_0x67f: __NO_MATCH()
    dest_0x68f: __NO_MATCH()
    dest_0x69f: __NO_MATCH()
    dest_0x6af: __NO_MATCH()
    dest_0x6bf: __NO_MATCH()
    dest_0x6cf: __NO_MATCH()
    dest_0x6df: __NO_MATCH()
    dest_0x6ef: __NO_MATCH()
    dest_0x6ff: __NO_MATCH()
    dest_0x70f: __NON_PAYABLE_FUNC_CHECK(0x70a08231, balanceOf_final_dest)
    dest_0x71f: __NO_MATCH()
    dest_0x72f: __NO_MATCH()
    dest_0x73f: __NO_MATCH()
    dest_0x74f: __NO_MATCH()
    dest_0x75f: __NO_MATCH()
    dest_0x76f: __NO_MATCH()
    dest_0x77f: __NO_MATCH()
    dest_0x78f: __NO_MATCH()
    dest_0x79f: __NO_MATCH()
    dest_0x7af: __NO_MATCH()
    dest_0x7bf: __NO_MATCH()
    dest_0x7cf: __NO_MATCH()
    dest_0x7df: __NO_MATCH()
    dest_0x7ef: __NO_MATCH()
    dest_0x7ff: __NO_MATCH()
    dest_0x80f: __NO_MATCH()
    dest_0x81f: __NO_MATCH()
    dest_0x82f: __NO_MATCH()
    dest_0x83f: __NO_MATCH()
    dest_0x84f: __NO_MATCH()
    dest_0x85f: __NON_PAYABLE_FUNC_CHECK(0x853828b6, withdrawAll_final_dest)
    dest_0x86f: __NO_MATCH()
    dest_0x87f: __NO_MATCH()
    dest_0x88f: __NO_MATCH()
    dest_0x89f: __NO_MATCH()
    dest_0x8af: __NO_MATCH()
    dest_0x8bf: __NO_MATCH()
    dest_0x8cf: __NO_MATCH()
    dest_0x8df: __NO_MATCH()
    dest_0x8ef: __NO_MATCH()
    dest_0x8ff: __NO_MATCH()
    dest_0x90f: __NO_MATCH()
    dest_0x91f: __NO_MATCH()
    dest_0x92f: __NO_MATCH()
    dest_0x93f: __NO_MATCH()
    dest_0x94f: __NON_PAYABLE_FUNC_CHECK(0x9470b0bd, withdrawFrom_final_dest)
    dest_0x95f: __NON_PAYABLE_FUNC_CHECK(0x95d89b41, symbol_final_dest)
    dest_0x96f: __NO_MATCH()
    dest_0x97f: __NO_MATCH()
    dest_0x98f: __NO_MATCH()
    dest_0x99f: __NO_MATCH()
    dest_0x9af: __NO_MATCH()
    dest_0x9bf: __NO_MATCH()
    dest_0x9cf: __NO_MATCH()
    dest_0x9df: __NO_MATCH()
    dest_0x9ef: __NO_MATCH()
    dest_0x9ff: __NO_MATCH()
    dest_0xa0f: __NO_MATCH()
    dest_0xa1f: __NO_MATCH()
    dest_0xa2f: __NO_MATCH()
    dest_0xa3f: __NO_MATCH()
    dest_0xa4f: __NO_MATCH()
    dest_0xa5f: __NO_MATCH()
    dest_0xa6f: __NO_MATCH()
    dest_0xa7f: __NO_MATCH()
    dest_0xa8f: __NO_MATCH()
    dest_0xa9f: __NON_PAYABLE_FUNC_CHECK(0xa9059cbb, transfer_final_dest)
    dest_0xaaf: __NO_MATCH()
    dest_0xabf: __NO_MATCH()
    dest_0xacf: __NO_MATCH()
    dest_0xadf: __NO_MATCH()
    dest_0xaef: __NO_MATCH()
    dest_0xaff: __NO_MATCH()
    dest_0xb0f: __NO_MATCH()
    dest_0xb1f: __NO_MATCH()
    dest_0xb2f: __NO_MATCH()
    dest_0xb3f: __NO_MATCH()
    dest_0xb4f: __NO_MATCH()
    dest_0xb5f: __NO_MATCH()
    dest_0xb6f: __NO_MATCH()
    dest_0xb7f: __PAYABLE_FUNC_CHECK(0xb760faf9, depositTo_final_dest)
    dest_0xb8f: __NO_MATCH()
    dest_0xb9f: __NO_MATCH()
    dest_0xbaf: __NO_MATCH()
    dest_0xbbf: __NO_MATCH()
    dest_0xbcf: __NO_MATCH()
    dest_0xbdf: __NO_MATCH()
    dest_0xbef: __NO_MATCH()
    dest_0xbff: __NO_MATCH()
    dest_0xc0f: __NO_MATCH()
    dest_0xc1f: __NO_MATCH()
    dest_0xc2f: __NO_MATCH()
    dest_0xc3f: __NO_MATCH()
    dest_0xc4f: __NO_MATCH()
    dest_0xc5f: __NO_MATCH()
    dest_0xc6f: __NO_MATCH()
    dest_0xc7f: __NO_MATCH()
    dest_0xc8f: __NO_MATCH()
    dest_0xc9f: __NO_MATCH()
    dest_0xcaf: __NON_PAYABLE_FUNC_CHECK(0xca9add8f, withdrawAllTo_final_dest)
    dest_0xcbf: __NO_MATCH()
    dest_0xccf: __NO_MATCH()
    dest_0xcdf: __NO_MATCH()
    dest_0xcef: __NO_MATCH()
    dest_0xcff: __NO_MATCH()
    dest_0xd0f: __PAYABLE_FUNC_CHECK(0xd0e30db0, deposit_final_dest)
    dest_0xd1f: __NO_MATCH()
    dest_0xd2f: __NO_MATCH()
    dest_0xd3f: __NO_MATCH()
    dest_0xd4f: __NO_MATCH()
    dest_0xd5f: __NO_MATCH()
    dest_0xd6f: __NO_MATCH()
    dest_0xd7f: __NO_MATCH()
    dest_0xd8f: __NO_MATCH()
    dest_0xd9f: __NO_MATCH()
    dest_0xdaf: __NO_MATCH()
    dest_0xdbf: __NO_MATCH()
    dest_0xdcf: __NO_MATCH()
    dest_0xddf: __NON_PAYABLE_FUNC_CHECK(0xdd62ed3e, allowance_final_dest)
    dest_0xdef: __NO_MATCH()
    dest_0xdff: __NO_MATCH()
    dest_0xe0f: __NO_MATCH()
    dest_0xe1f: __NO_MATCH()
    dest_0xe2f: __NO_MATCH()
    dest_0xe3f: __NO_MATCH()
    dest_0xe4f: __NO_MATCH()
    dest_0xe5f: __NO_MATCH()
    dest_0xe6f: __NO_MATCH()
    dest_0xe7f: __NO_MATCH()
    dest_0xe8f: __NO_MATCH()
    dest_0xe9f: __NO_MATCH()
    dest_0xeaf: __NO_MATCH()
    dest_0xebf: __NO_MATCH()
    dest_0xecf: __NO_MATCH()
    dest_0xedf: __NO_MATCH()
    dest_0xeef: __NO_MATCH()
    dest_0xeff: __NO_MATCH()
    dest_0xf0f: __NO_MATCH()
    dest_0xf1f: __NO_MATCH()
    dest_0xf2f: __NO_MATCH()
    dest_0xf3f: __NO_MATCH()
    dest_0xf4f: __NO_MATCH()
    dest_0xf5f: __NO_MATCH()
    dest_0xf6f: __NO_MATCH()
    dest_0xf7f: __NO_MATCH()
    dest_0xf8f: __NO_MATCH()
    dest_0xf9f: __NO_MATCH()
    dest_0xfaf: __NO_MATCH()
    dest_0xfbf: __NO_MATCH()
    dest_0xfcf: __NO_MATCH()
    dest_0xfdf: __NO_MATCH()
    dest_0xfef: __NO_MATCH()
    dest_0xfff: __NO_MATCH()

    // Final function destinations.
    name_final_dest:
        NAME()
    symbol_final_dest:
        SYMBOL()
    decimals_final_dest:
        DECIMALS()
    totalSupply_final_dest:
        TOTAL_SUPPLY()
    transferFrom_final_dest:
        TRANSFER_FROM()
    transfer_final_dest:
        TRANSFER()
    balanceOf_final_dest:
        BALANCE_OF()
    approve_final_dest:
        APPROVE()
    allowance_final_dest:
        ALLOWANCE()
    // For payable functions `RETURNDATASIZE` is used as 2 gas `PUSH0` instead of `CALLVALUE`
    deposit_final_dest:
        DEPOSIT()
    depositTo_final_dest:
        DEPOSIT_TO()
    depositAndApprove_final_dest:
        DEPOSIT_AND_APPROVE()
    withdraw_final_dest:
        WITHDRAW()
    withdrawTo_final_dest:
        WITHDRAW_TO()
    withdrawAll_final_dest:
        WITHDRAW_ALL()
    withdrawAllTo_final_dest:
        WITHDRAW_ALL_TO()
    withdrawFrom_final_dest:
        WITHDRAW_FROM()
    withdrawFromTo_final_dest:
        WITHDRAW_FROM_TO()
    rescueLost_final_dest:
        RESCUE_LOST()

    // Errors.
    insufficient_bal_error:
        __FUNC_SIG(InsufficientBalance)
        _REVERT()
    insufficient_allowance_error:
        __FUNC_SIG(InsufficientAllowance)
        _REVERT()
    permit_expired_error:
        __FUNC_SIG(PermitExpired)
        _REVERT()
    invalid_signature_error:
        __FUNC_SIG(InvalidSignature)
        _REVERT()
    fork_error:
        __FUNC_SIG(Fork)
        _REVERT()
    empty_revert:
        push0 push0 revert
}
